--- a/freminal-terminal-emulator/src/ansi.rs
+++ b/freminal-terminal-emulator/src/ansi.rs
@@ -785,3 +785,15 @@
         }
     }
 }
+
+
+impl SequenceTraceable for AnsiParser {
+    #[inline]
+    fn seq_trace(&mut self) -> &mut Vec<u8> {
+        &mut self.seq_trace
+    }
+    #[inline]
+    fn seq_trace_ref(&self) -> &Vec<u8> {
+        &self.seq_trace
+    }
+}
--- a/freminal-terminal-emulator/src/ansi_components/osc.rs
+++ b/freminal-terminal-emulator/src/ansi_components/osc.rs
@@ -266,7 +266,7 @@
                 } else {
                     warn!("Invalid OSC param: {:x}", b);
                     {
-                        self.state = AnsiOscParserState::Invalid;
+                        self.state = AnsiOscParserState::Invalid; self.clear_trace();
                         self.params.clear();
                         self.intermediates.clear();
 
@@ -275,7 +275,7 @@
                 }
 
                 if is_osc_terminator(&self.params) {
-                    self.state = AnsiOscParserState::Finished;
+                    self.state = AnsiOscParserState::Finished; self.clear_trace();
                     self.seq_trace.trim_control_tail();
 
                     if !self.params.is_empty() {
@@ -472,3 +472,15 @@
     // get the parameter at the index
     params.get(idx).and_then(std::clone::Clone::clone)
 }
+
+
+impl SequenceTraceable for AnsiOscParser {
+    #[inline]
+    fn seq_trace(&mut self) -> &mut Vec<u8> {
+        &mut self.seq_trace
+    }
+    #[inline]
+    fn seq_trace_ref(&self) -> &Vec<u8> {
+        &self.seq_trace
+    }
+}
--- a/freminal-terminal-emulator/src/ansi_components/csi.rs
+++ b/freminal-terminal-emulator/src/ansi_components/csi.rs
@@ -95,12 +95,12 @@
                     return ParserOutcome::Finished;
                 }
 
-                self.state = AnsiCsiParserState::Invalid;
+                self.state = AnsiCsiParserState::Invalid; self.clear_trace();
                 ParserOutcome::Invalid("Invalid CSI parameter".to_string())
             }
             AnsiCsiParserState::Intermediates => {
                 if is_csi_param(b) {
-                    self.state = AnsiCsiParserState::Invalid;
+                    self.state = AnsiCsiParserState::Invalid; self.clear_trace();
                     return ParserOutcome::Invalid("Invalid CSI intermediate".to_string());
                 } else if is_csi_intermediate(b) {
                     self.intermediates.push(b);
@@ -111,7 +111,7 @@
                     return ParserOutcome::Finished;
                 }
 
-                self.state = AnsiCsiParserState::Invalid;
+                self.state = AnsiCsiParserState::Invalid; self.clear_trace();
                 ParserOutcome::Invalid("Invalid CSI intermediate".to_string())
             }
             AnsiCsiParserState::Invalid => {
@@ -239,3 +239,15 @@
 fn is_csi_intermediate(b: u8) -> bool {
     (0x20..=0x2f).contains(&b)
 }
+
+
+impl SequenceTraceable for AnsiCsiParser {
+    #[inline]
+    fn seq_trace(&mut self) -> &mut Vec<u8> {
+        &mut self.seq_trace
+    }
+    #[inline]
+    fn seq_trace_ref(&self) -> &Vec<u8> {
+        &self.seq_trace
+    }
+}
--- a/freminal-terminal-emulator/src/ansi_components/standard.rs
+++ b/freminal-terminal-emulator/src/ansi_components/standard.rs
@@ -97,7 +97,7 @@
         match self.state {
             StandardParserState::Intermediates => {
                 if is_standard_intermediate_final(b) {
-                    self.state = StandardParserState::Finished;
+                    self.state = StandardParserState::Finished; self.clear_trace();
                     self.seq_trace.trim_control_tail();
                     self.intermediates.push(b);
 
@@ -115,7 +115,7 @@
                     return ParserOutcome::Continue;
                 }
 
-                self.state = StandardParserState::Invalid;
+                self.state = StandardParserState::Invalid; self.clear_trace();
                 ParserOutcome::Invalid("Invalid intermediate byte".to_string())
             }
             StandardParserState::Params => {
@@ -123,7 +123,7 @@
                     self.params.push(b);
 
                     if self.contains_string_terminator() {
-                        self.state = StandardParserState::Finished;
+                        self.state = StandardParserState::Finished; self.clear_trace();
                         self.seq_trace.trim_control_tail();
                         return ParserOutcome::Finished;
                     }
@@ -131,13 +131,13 @@
                     return ParserOutcome::Continue;
                 } else if is_standard_param(b) {
                     self.params.push(b);
-                    self.state = StandardParserState::Finished;
+                    self.state = StandardParserState::Finished; self.clear_trace();
                     self.seq_trace.trim_control_tail();
 
                     return ParserOutcome::Finished;
                 }
 
-                self.state = StandardParserState::Invalid;
+                self.state = StandardParserState::Invalid; self.clear_trace();
                 ParserOutcome::Invalid("Invalid parameter byte".to_string())
             }
 
@@ -463,3 +463,27 @@
             | 0x3d
     )
 }
+
+
+impl SequenceTraceable for StandardParser {
+    #[inline]
+    fn seq_trace(&mut self) -> &mut Vec<u8> {
+        &mut self.seq_trace
+    }
+    #[inline]
+    fn seq_trace_ref(&self) -> &Vec<u8> {
+        &self.seq_trace
+    }
+}
+
+
+impl SequenceTraceable for AnsiStandardParser {
+    #[inline]
+    fn seq_trace(&mut self) -> &mut Vec<u8> {
+        &mut self.seq_trace
+    }
+    #[inline]
+    fn seq_trace_ref(&self) -> &Vec<u8> {
+        &self.seq_trace
+    }
+}
--- a/freminal-terminal-emulator/src/ansi_components/tracer.rs
+++ b/freminal-terminal-emulator/src/ansi_components/tracer.rs
@@ -71,3 +71,28 @@
         }
     }
 }
+
+
+/// A small helper trait that standardizes how parsers collect and present
+/// the raw bytes of the *current* sequence they are parsing.
+pub trait SequenceTraceable {
+    /// Mutable access to the underlying sequence trace buffer.
+    fn seq_trace(&mut self) -> &mut Vec<u8>;
+    /// Immutable access to the underlying sequence trace buffer.
+    fn seq_trace_ref(&self) -> &Vec<u8>;
+
+    /// Append a single byte to the sequence trace.
+    fn append_trace(&mut self, b: u8) {
+        self.seq_trace().push(b);
+    }
+
+    /// Clear the current sequence trace (typically on Finished/Invalid/Reset).
+    fn clear_trace(&mut self) {
+        self.seq_trace().clear();
+    }
+
+    /// Render the current trace as a lossy UTF-8 string for diagnostics.
+    fn current_trace_str(&self) -> String {
+        String::from_utf8_lossy(self.seq_trace_ref()).into_owned()
+    }
+}
